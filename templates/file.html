{% extends 'base.html' %}

{% block pagetitle %}
  {{"File Viewer"}}
{% endblock %}

{% block contenttitle %}{% endblock %}

{% block head_extra %}
  <style>
    .full_file {
      max-width: 100%;
      max-height: 100vh;
    }

    .full_file_sidebar {
      display: block;
      margin-right: 1em;
      font-size: 80%;
      width: 230px;
      float: left;
      overflow: auto;
      max-height: calc(100% - 75);
    }

    .full_file_container {
      display: block;
      float: left;
      width: calc(100% - 300px);
    }

    .tag_list {
      padding: 0 0 0 16px;
      margin: 0;
    }

    @media screen and (max-width: 721px) {
      .full_file_sidebar {
        display: block;
        float: none;
        width: 100%;
        margin-bottom: 16px;
        font-size: 100%;
      }

      .full_file_container {
        display: block;
        float: none;
        width: 100%;
      }
    }
  </style>
  <script src="{{ url_for('static', filename='js/async_helper.js') }}"></script>
  <script src="{{ url_for('static', filename='js/tag_presentation_helper.js') }}"></script>
  <script>
    // we store the actions here for reference later. we will populate them
    // at a later time too.
    var fileActions = {};
    var shortcutsToActionNames = {};

    var currentMetadata = null;
    var currentFileID = null;
    var currentRule = null;

    var playlist = null;
    var playlistPosition = null;

    var archetypeFuncs = {
      'noop': async function () {},

      'move_to_trash': async function () {
        await httpPostJson('/api/files/move_to_trash', {"file_ids": getCurrentFileID()}).then(redownloadFileMetadata)
      },

      'move_to_inbox': async function () {
        await httpPostJson('/api/files/move_to_inbox', {"file_ids": getCurrentFileID()}).then(redownloadFileMetadata)
      },

      'move_to_archive': async function () {
        await httpPostJson('/api/files/move_to_archive', {"file_ids": getCurrentFileID()}).then(redownloadFileMetadata)
      },

      'quick_add_tag': async function () {
        var tag = prompt("Please enter a tag to add to the file. The tag will be added to '" + getTagService() + "'")
        if (tag != null && tag != "") {
          await changeTags(tag, null);
        }
      },

      'quick_delete_tag': async function () {
        var tag = prompt("Please enter a tag to remove from the file. The tag will be removed from '" + getTagService() + "'")
        if (tag != null && tag != "") {
          await changeTags(null, tag);
        }
      },

      'change_tags': async function (hints) {
        await changeTags(hints.add_tags, hints.rm_tags)
      },

      'move': async function (hints) {
        movement = hints.movement || 1;
        await moveInPlaylist(movement);
      }
    }

    document.onkeydown = async function (e) {
      e = e || window.event;
      if (e.ctrlKey && e.keyCode == 90) {
        alert("undo not implemented (yet?)")
        return true;
      }
      shortcutName = "";
      if (e.ctrlKey) {
        shortcutName += "ctrl+";
      }
      if (e.altKey) {
        shortcutName += "alt+";
      }
      if (e.shiftKey) {
        shortcutName += "shift+";
      }
      shortcutName += e.key;
      shortcutName = shortcutName.toLowerCase();
      // console.log(shortcutName);
      return await !onAction(shortcutsToActionNames[shortcutName]);
    };

    async function changePageState(changes = {}) {
      var fileIDChanged = false;
      var metadataChanged = false;
      var ruleChanged = false;

      if (changes.fileID != null) {
        currentFileID = parseInt(changes.fileID + "");
        fileIDChanged = true;
      }

      if (fileIDChanged || changes.updateMetadata) {
        currentMetadata = await httpGetJson('/api/files/get_metadata?file_id=' + encodeURI(currentFileID));
        metadataChanged = true;
      }

      if (changes.ruleName != null || changes.updateRule) {
        var ruleName = changes.ruleName;
        if (ruleName == null && currentRule != null) {
          ruleName = currentRule.name;
        }
        currentRule = await httpGetJson('/api/rules/get_rule?name=' + encodeURI(changes.ruleName));
        ruleChanged = true;
      }

      var pendingActions = [];

      // update tags list
      if (metadataChanged) {
        var tagsContainer = document.getElementById("tags_container")
        tagsContainer.innerHTML = ""
        tagsContainer.appendChild(createTagList(getDisplayTagsFromMetadata(getTagService(), getCurrentMetadata())))
      }

      if (ruleChanged) {
        // update rule info components
        pendingActions.push(renderRuleComponents());

        // redownload playlist
        if (currentRule != null) {
          playlist = await httpGetJson('/api/rules/get_files?name=' + currentRule.name);
        }
      }

      if (fileIDChanged) {
        // update embed
        pendingActions.push(renderFileEmbed());
      }

      if (fileIDChanged || ruleChanged) {
        // update position in playlist
        if (playlist != null) {
          playlistPosition = playlist.indexOf(currentFileID);
          // console.log(playlistPosition, currentFileID, playlist);
        }
      }

      if (metadataChanged || ruleChanged) {
        // update actions list
        pendingActions.push(renderActionComponents());
      }

      // console.log(changes, {fileIDChanged, metadataChanged, ruleChanged});
      return await Promise
        .allSettled(pendingActions)
        .then(console.log("Render done"));
    }

    async function moveInPlaylist(motion) {
      if (playlist == null || motion == null || motion == 0 || playlist.length == 0) {
        return;
      }
      if (playlistPosition == null || playlistPosition == -1) {
        playlistPosition = 0;
      } else {
        playlistPosition += motion;
      }
      if (playlistPosition >= playlist.length) {
        playlistPosition = 0;
      } else if (playlistPosition < 0) {
        playlistPosition = playlist.length - 1;
      }
      await changePageState({fileID: playlist[playlistPosition]});
    }

    async function redownloadFileMetadata() {
      await changePageState({updateMetadata: true})
    }

    function getTagService() {
      return "{{server.tag_service}}";
    }

    function getCurrentMetadata() {
      return currentMetadata;
    }

    function getCurrentFileID() {
      return currentFileID;
    }

    function getCurrentRule() {
      return currentRule;
    }

    async function renderFileEmbed() {
      console.log("Rendering file embed...");

      var metadata = getCurrentMetadata();
      var fileID = metadata.file_id;
      var mime = metadata.mime;
      var src = "/files/full/" + encodeURI(fileID);

      var embedTarget = document.getElementById("embed_target");
      embedTarget.innerHTML = ""
      embedTarget.appendChild(createEmbedElement(metadata, src));

      var title = "File #" + metadata.file_id;

      document
        .getElementById("file_title")
        .textContent = title;
      // elem("uploader-name").textContent = metadata.uploader;
      // elem("uploaded-time").textContent = timeToSring(metadata.uploaded);

      var elemDownload = document.getElementById("direct_download");
      elemDownload.innerHTML = "<span>Direct Download (<code>" + metadata.mime + "</code>)</span>";
      elemDownload.href = src;
    }

    async function renderRuleComponents() {
      var ruleData = getCurrentRule();
      var ruleName = ruleData.name;

      var ruleHeader = document.getElementById("rule_header");
      var ruleContainer = document.getElementById("rule_container");

      ruleHeader.innerText = "Rule: " + ruleName;
      ruleHeader.style = "";

      ruleContainer.innerHTML = "";

      if (ruleData.note) {
        var ruleNoteElem = document.createElement("p");
        ruleNoteElem.innerText = ruleData.note;
        ruleContainer.appendChild(ruleNoteElem);
      }

      var ruleLinkElem = document.createElement("a");
      ruleLinkElem.innerText = "(Rule Page)";
      ruleLinkElem.href = "/rules/" + encodeURI(ruleName);
      ruleContainer.appendChild(ruleLinkElem);
    }

    async function renderActionComponents() {
      var actionsContainer = document.getElementById("actions_container");
      actionsContainer.innerHTML = "";

      fileActions = {};
      shortcutsToActionNames = {};

      var defaultActions = await httpGetJson('/api/server/get_global_file_actions');

      var location = getLocationFromMetadata(getCurrentMetadata());

      function maybeRender(action) {

        fileActions[action.name] = action;

        if (action.shortcut != null) {
          shortcut = action
            .shortcut
            .toLowerCase();
          console.log("Adding shortcut: " + shortcut + " -> " + action.name);
          shortcutsToActionNames[shortcut] = action.name;
        }

        var hidden = action.hidden;
        hidden = hidden || (action.hiddenIfInbox && location == 'inbox');
        hidden = hidden || (action.hiddenIfArchive && location == 'archive');
        hidden = hidden || (action.hiddenIfTrash && location == 'trash');

        if (hidden) {
          console.log('not rendering action: ' + action.name);
          return;
        }
        elem = createActionButton(action);
        actionsContainer.appendChild(elem);
        actionsContainer.append(document.createElement("br"));
      }

      if (defaultActions != null) {
        for (var i = 0; i < defaultActions.length; i++) {
          maybeRender(defaultActions[i]);
        }
      }

      var rule = getCurrentRule();
      if (rule != null) {
        var ruleActions = rule.actions;
        if (ruleActions != null && ruleActions.length > 0) {
          // if (defaultActions != null && defaultActions.length > 0) {
          // add a divider?
          // }
          for (var i = 0; i < ruleActions.length; i++) {
            maybeRender(ruleActions[i]);
          }
        }
      }
    }

    async function changeTags(addTags, rmTags) {
      return await httpPostJson('/api/files/change_tags', {
        'file_ids': parseInt(getCurrentFileID() + ""),
        'add_tags': addTags,
        'rm_tags': rmTags
      })
        .then(redownloadFileMetadata)
        .catch(e => "Failed to change tags: " + e);
    }

    /** Returns true if there is a matching action */
    async function onAction(actionName) {
      if (actionName == null) {
        return false;
      }

      action = fileActions[actionName];

      if (action == null) {
        console.log('no action for: ' + actionName, fileActions)
        return false;
      }

      var archetype = action.archetype;
      if (archetype == null) {
        alert(actionName + " does not have an archetype, doing nothing");
        return true;
      }

      var func = archetypeFuncs[
        archetype
          .trim()
          .toLowerCase()
      ];

      if (func != null) {
        func(action.hints)
          .then(x => {
            if (action.resolves) {
              moveInPlaylist(1);
            }
          })
          .catch(err => {
            alert("Execution of '" + actionName + "' failed: " + err);
          });

        return true;
      }

      alert(actionName + " has an unknown/unsupported archetype: '" + archetype + "'");
      return true;
    }

    async function onShortcut(shortcut) {
      actionName = shortcutsToActionNames[shortcut];
      if (actionName != null) {
        return await onAction(actionName);
      }
    }

    /** Creates an element to display the file in based on the mimetype */
    function createEmbedElement(metadata, src) {
      var mime = metadata.mime;

      // i do URI encoding out of paranoia
      var fileID = metadata.file_id;
      var fileIDURI = encodeURI(fileID + "");

      var classNameFullFile = "full_file";

      /** Creates a source element, needed for some cases below */
      function createSourceElement() {
        var source = document.createElement("source");
        source.src = src;
        source.type = mime;
        return source;
      }

      if (mime.startsWith("image")) {
        // for images, create a simple img element
        var e = document.createElement("img");
        e.src = src;
        e.className = classNameFullFile;
        return e;
      } else if (mime.startsWith("audio")) {
        // audio -> audio element
        var e = document.createElement("audio");
        e.className = classNameFullFile;
        e.controls = true;
        e.appendChild(createSourceElement());
        return e
      } else if (mime.startsWith("video")) {
        // videos -> video element
        var e = document.createElement("video");
        e.className = classNameFullFile;
        e.controls = true;
        e.appendChild(createSourceElement());
        return e
      } else {
        // We don't know how to render that file so we throw up the thumbnail
        var e = document.createElement("div");
        var span = document.createElement("span");
        span.innerText = "The MIME type of this file is not supported.";
        e.appendChild(span);
        e.appendChild(document.createElement("br"));
        var img = document.createElement("img");
        img.className = "thumbnail";
        img.src = "/files/thumbnail/" + fileIDURI;
        e.appendChild(img);
        return e
      }
    }

    function getDisplayTagsFromMetadata(service, metadata) {
      return metadata['service_names_to_statuses_to_display_tags'][service]['0'];
    }

    function getTagsFromMetadata(service, metadata) {
      return metadata['service_names_to_statuses_to_tags'][service]['0'];
    }

    function getLocationFromMetadata(metadata) {
      if (metadata != null) {
        if (metadata.is_trashed) {
          return 'trash';
        }
        if (metadata.is_inbox) {
          return 'inbox';
        } else {
          return 'archive';
        }
      }
      return 'unknown';
    }

    function createActionButton(action) {
      var span = document.createElement('span');
      var innerText = action.name;
      if (action.shortcut != null) {
        innerText += " (" + action.shortcut + ")";
      }
      span.innerText = innerText;
      span.className += "icon_left icon_left_" + action.icon;

      var e = document.createElement('button');
      e.className = "anchorbutton";
      e.appendChild(span);
      e.onclick = async function () {
        await onAction(action.name);
      }
      return e;
    }

    window.addEventListener("load", async function () {
      var params = new URLSearchParams(window.location.search);
      var file = params.get("file");
      var rule = params.get("rule");

      await changePageState({fileID: file, ruleName: rule});
    })
  </script>
{% endblock %}

{% block content %}
  <div class="full_file_sidebar">
    <h2 id="file_title"></h2>
    <p>
      <a id="direct_download">Direct Download</a>
    </p>

    <!-- <h3>Tools</h3> <button onclick="addTag()">Quick Add Tag</button><br> <button onclick="removeTag()">Quick Remove Tag</button><br> -->

    <h3 id="actions_header">Actions</h3>
    <div id="actions_container"></div>

    <h3 id="tags_header">Display Tags ({{server.tag_service}})</h3>
    <div id="tags_container"></div>

    <h3 id="rule_header" style="display: none;">Rule Info</h3>
    <div id="rule_container"></div>
  </div>

  <div id="embed_target" class="full_file_container"></div>

{% endblock %}
