{% extends 'base.html' %}

{% block pagetitle %}
  {{"File Viewer"}}
{% endblock %}

{% block contenttitle %}{% endblock %}

{% block head_extra %}
  <style>
    .full_file {
      max-width: 100%;
      max-height: 100vh;
    }

    .full_file_sidebar {
      display: block;
      margin-right: 1em;
      font-size: 80%;
      width: 230px;
      float: left;
      overflow: auto;
      max-height: calc(100% - 75);
    }

    .full_file_sidebar p {
      max-width: 100%;
      word-wrap: normal;
      overflow-x: auto;
    }

    .full_file_container {
      display: block;
      float: left;
      width: calc(100% - 300px);
    }

    .tag_list {
      padding: 0 0 0 16px;
      margin: 0;
    }

    #actions_container .anchorbutton {
      text-align: left;
    }

    @media screen and (max-width: 721px) {
      .full_file_sidebar {
        display: block;
        float: none;
        width: 100%;
        margin-bottom: 16px;
        font-size: 100%;
      }

      .full_file_container {
        display: block;
        float: none;
        width: 100%;
      }
    }
  </style>
  <script type="module">
    import TagList from "/static/js/TagList.js"

    import {httpGetJson, httpPostJson} from "/static/js/http_helper.js"
    import {getTagServices, getTags, getAllKnownTags, STATUS_CURRENT} from "/static/js/tags.js"
    import {getFileMetadata} from "/static/js/api.js"
    import {renderEmbedElement} from "/static/js/file_embeds.js"
    import {getRuleInfo, getRuleFiles, getRuleExemptions} from "/static/js/rules.js"

    // shortcuts to assign to actions with the 'auto' shortcut
    var autoShortcuts = "qwerty1234567890uiopghjklvbnm".split("");

    // we store the actions here for reference later. we will populate them
    // at a later time too.
    var tagList;

    var fileActions = {};
    var shortcutsToActionNames = {};

    var currentTagService = "my tags";
    var currentFileMetadata = null;
    var currentFileId = null;
    var currentRule = null;

    var playlist = null;
    var playlistPosition = null;

    var archetypeFuncs = {
      'noop': async function () {},

      'move_to_trash': async function () {
        await httpPostJson('/api/files/move_to_trash', {"file_ids": getCurrentFileID()}).then(redownloadFileMetadata)
      },

      'move_to_inbox': async function () {
        await httpPostJson('/api/files/move_to_inbox', {"file_ids": getCurrentFileID()}).then(redownloadFileMetadata)
      },

      'move_to_archive': async function () {
        await httpPostJson('/api/files/move_to_archive', {"file_ids": getCurrentFileID()}).then(redownloadFileMetadata)
      },

      'quick_add_tag': async function () {
        var tag = prompt("Please enter a tag to add to the file. The tag will be added to '" + getCurrentTagService() + "'")
        if (tag != null && tag != "") {
          await changeTags(tag, null);
        }
      },

      'quick_delete_tag': async function () {
        var tag = prompt("Please enter a tag to remove from the file. The tag will be removed from '" + getCurrentTagService() + "'")
        if (tag != null && tag != "") {
          await changeTags(null, tag);
        }
      },

      'change_tags': async function (hints) {
        await changeTags(hints.add_tags, hints.rm_tags)
      },

      'move': async function (hints) {
        let movement = hints.movement || 1;
        await moveInPlaylist(movement);
      },

      'mark_as_exempt': async function () {
        var rule = getCurrentRule();
        if (rule != null) {
          await changeTags([rule.exempt_tag], null);
        } else {
          alert("cannot mark as an exception because there is no rule in the current context");
        }
      },

      'unmark_as_exempt': async function () {
        var rule = getCurrentRule();
        if (rule != null) {
          await changeTags(null, [rule.exempt_tag]);
        } else {
          alert("cannot unmark as an exception because there is no rule in the current context");
        }
      }
    }

    document.onkeydown = async function (e) {
      e = e || window.event;
      if (e.ctrlKey && e.keyCode == 90) {
        alert("undo not implemented (yet?)")
        return true;
      }
      var shortcutName = "";
      if (e.ctrlKey) {
        shortcutName += "ctrl+";
      }
      if (e.altKey) {
        shortcutName += "alt+";
      }
      if (e.shiftKey) {
        shortcutName += "shift+";
      }
      shortcutName += e.key;
      shortcutName = shortcutName.toLowerCase();
      // console.log(shortcutName);
      if (shortcutName == "shift+r") {
        await redownloadFileMetadata();
        return true;
      }
      return await !onAction(shortcutsToActionNames[shortcutName]);
    };

    async function changePageState(changes = {}) {
      var fileIdChanged = false;
      var metadataChanged = false;
      var ruleChanged = false;

      if (changes.fileID != null) {
        currentFileId = parseInt(changes.fileID + "");
        fileIdChanged = true;
      }

      if (fileIdChanged || changes.updateMetadata) {
        currentFileMetadata = await getFileMetadata(currentFileId, true);
        metadataChanged = true;
      }

      if (changes.ruleName != null || changes.updateRule) {
        var ruleName = changes.ruleName;
        if (ruleName == null && currentRule != null) {
          ruleName = currentRule.name;
        }
        currentRule = await getRuleInfo(changes.ruleName);
        ruleChanged = true;
      }

      var pendingActions = [];

      // update tags list & other metadata doodads
      if (metadataChanged) {
        var metadata = await getCurrentMetadata();

        tagList.setTags(await getCurrentTags());

        var hash = metadata.hash || "?";
        document
          .getElementById("hash_container")
          .innerText = hash;
      }

      if (ruleChanged) {
        // update rule info components
        pendingActions.push(renderRuleComponents());

        // redownload playlist
        if (currentRule != null) {
          if (changes.useRuleExemptions) {
            playlist = await getRuleExemptions(currentRule.name);
          } else {
            playlist = await getRuleFiles(currentRule.name);
          }
        }
      }

      if (fileIdChanged) {
        // update embed
        pendingActions.push(renderFileEmbed());
      }

      if (fileIdChanged || ruleChanged) {
        // update position in playlist
        if (playlist != null) {
          playlistPosition = playlist.indexOf(currentFileId);
          // console.log(playlistPosition, currentFileID, playlist);
        }
      }

      if (metadataChanged || ruleChanged) {
        // update actions list
        pendingActions.push(renderActionComponents());
      }

      // console.log(changes, {fileIDChanged, metadataChanged, ruleChanged});
      return await Promise.all(pendingActions);
    }

    async function moveInPlaylist(motion) {
      if (playlist == null || motion == null || motion == 0 || playlist.length == 0) {
        return;
      }
      var lastPlaylistPos = playlistPosition;
      if (playlistPosition == null || playlistPosition == -1) {
        playlistPosition = 0;
      } else {
        playlistPosition += motion;
      }
      if (playlistPosition >= playlist.length) {
        playlistPosition = 0;
      } else if (playlistPosition < 0) {
        playlistPosition = playlist.length - 1;
      }
      if (lastPlaylistPos !== playlistPosition) {
        await changePageState({fileID: playlist[playlistPosition]});
      }
    }

    async function redownloadFileMetadata() {
      await changePageState({updateMetadata: true})
    }

    function getCurrentTagService() {
      return currentTagService;
    }

    function getCurrentMetadata() {
      return currentFileMetadata;
    }

    function getCurrentFileID() {
      return currentFileId;
    }

    function getCurrentRule() {
      return currentRule;
    }

    async function renderFileEmbed() {
      var fileId = getCurrentFileID();
      var metadata = await getCurrentMetadata();
      var mime = metadata.mime;
      var src = "/files/full/" + encodeURI(fileId);

      var embed = await renderEmbedElement(fileId);
      var embedTarget = document.getElementById("embed_target");
      embedTarget.innerHTML = ""
      embedTarget.appendChild(embed);

      var title = "File #" + metadata.file_id;

      document
        .getElementById("file_title")
        .textContent = title;
      // elem("uploader-name").textContent = metadata.uploader;
      // elem("uploaded-time").textContent = timeToSring(metadata.uploaded);

      var elemDownload = document.getElementById("direct_download");
      elemDownload.innerHTML = "<span>Direct Download (<code>" + metadata.mime + "</code>)</span>";
      elemDownload.href = src;
    }

    async function renderRuleComponents() {
      var ruleData = getCurrentRule();
      var ruleName = ruleData.name;

      var ruleHeader = document.getElementById("rule_header");
      var ruleContainer = document.getElementById("rule_container");

      ruleHeader.innerText = "Rule: " + ruleName;
      ruleHeader.style = "";

      ruleContainer.innerHTML = "";

      if (ruleData.note) {
        var ruleNoteElem = document.createElement("p");
        ruleNoteElem.innerText = ruleData.note;
        ruleContainer.appendChild(ruleNoteElem);
      }

      var ruleLinkElem = document.createElement("a");
      ruleLinkElem.innerText = "(Rule Page)";
      ruleLinkElem.href = "/rules/" + encodeURI(ruleName);
      ruleContainer.appendChild(ruleLinkElem);
    }

    async function renderActionComponents() {
      var actionsContainer = document.getElementById("actions_container");
      actionsContainer.innerHTML = "";

      fileActions = {};
      shortcutsToActionNames = {};

      var defaultActions = await httpGetJson('/api/server/get_global_file_actions');

      var location = getCurrentFileLocation();
      // console.log(location)

      async function maybeRender(action) {

        fileActions[action.name] = action;

        if (action.shortcut != null) {
          var shortcut = action
            .shortcut
            .trim()
            .toLowerCase();

          if (shortcut == 'auto') {
            shortcut = null;
            for (var i = 0; i < autoShortcuts.length && shortcut == null; i++) {
              autoShortcut = autoShortcuts[i];
              if (shortcutsToActionNames[autoShortcut] == null) {
                shortcut = autoShortcut;
              }
            }
          }

          shortcutsToActionNames[shortcut] = action.name;
          action.shortcut = shortcut;
        }

        var rule = getCurrentRule();
        var hidden = action.hidden;
        hidden = hidden || (action.hiddenIfInbox && location == 'inbox');
        hidden = hidden || (action.hiddenIfArchive && location == 'archive');
        hidden = hidden || (action.hiddenIfTrash && location == 'trash');

        hidden = hidden || (action.hiddenIfNoRule && rule == null);
        hidden = hidden || (action.hiddenIfRule && rule != null);

        var exempt = rule != null && (await getCurrentFileHasTag(rule.exempt_tag));
        hidden = hidden || (action.hiddenIfExempt && exempt);
        hidden = hidden || (action.hiddenIfNotExempt && !exempt)

        if (hidden) {
          // console.log('not rendering action: ' + action.name);
          return;
        }
        var elem = createActionButton(action);
        actionsContainer.appendChild(elem);
        actionsContainer.append(document.createElement("br"));
      }

      if (defaultActions != null) {
        for (var i = 0; i < defaultActions.length; i++) {
          maybeRender(defaultActions[i]);
        }
      }

      var rule = getCurrentRule();
      if (rule != null) {
        var ruleActions = rule.actions;
        if (ruleActions != null && ruleActions.length > 0) {
          if (defaultActions != null && defaultActions.length > 0) {
            actionsContainer.append(document.createElement('br'))
          }
          for (var i = 0; i < ruleActions.length; i++) {
            await maybeRender(ruleActions[i]);
          }
        }
      }
    }

    async function changeTags(addTags, rmTags) {
      return await httpPostJson('/api/files/change_tags', {
        'tag_service': getCurrentTagService(),
        'file_ids': parseInt(getCurrentFileID() + ""),
        'add_tags': addTags,
        'rm_tags': rmTags
      })
        .then(redownloadFileMetadata)
        .catch(e => {
          alert("Failed to change tags: " + e + ", please check the console, expand the error, and screenshot as much as you can.");
          console.error(e);
        });
    }

    /** Returns true if there is a matching action */
    async function onAction(actionName) {
      if (actionName == null) {
        return false;
      }

      var action = fileActions[actionName];

      if (action == null) {
        console.log('no action for: ' + actionName, fileActions)
        return false;
      }

      var archetype = action.archetype;
      if (archetype == null) {
        alert(actionName + " does not have an archetype, doing nothing");
        return true;
      }

      var func = archetypeFuncs[
        archetype
          .trim()
          .toLowerCase()
      ];

      if (func != null) {
        func(action.hints)
          .then(x => {
            if (action.resolves) {
              moveInPlaylist(1);
            }
          })
          .catch(err => {
            alert("Execution of '" + actionName + "' failed: " + err + ". Please open the console, expand the error, and screenshot as much as you can. Thank you :)");
            console.error(err);
          });

        return true;
      }

      alert(actionName + " has an unknown/unsupported archetype: '" + archetype + "'");
      return true;
    }

    async function onShortcut(shortcut) {
      actionName = shortcutsToActionNames[shortcut];
      if (actionName != null) {
        return await onAction(actionName);
      }
    }

    async function getCurrentTags() {
      return await getTags(getCurrentFileID(), getCurrentTagService(), STATUS_CURRENT, true);
    }

    async function getCurrentAllKnownTags() {
      return await getAllKnownTags(getCurrentFileID(), STATUS_CURRENT, true);
    }

    async function getCurrentFileHasTag(tag) {
      return (await getCurrentAllKnownTags()).indexOf(tag) != -1;
    }

    function getCurrentFileLocation() {
      var metadata = getCurrentMetadata();
      if (metadata != null) {
        if (metadata.is_trashed) {
          return 'trash';
        }
        if (metadata.is_inbox) {
          return 'inbox';
        } else {
          return 'archive';
        }
      }
      return 'unknown';
    }

    function createActionButton(action) {
      var span = document.createElement('span');
      var innerText = action.name;
      if (action.shortcut != null) {
        innerText += " (" + action.shortcut + ")";
      }
      span.innerText = innerText;
      span.className += "icon_left icon_left_" + action.icon;

      var e = document.createElement('button');
      e.className = "anchorbutton";
      e.appendChild(span);
      e.onclick = async function () {
        await onAction(action.name);
      }
      return e;
    }

    window.addEventListener("load", async function () {
      var params = new URLSearchParams(window.location.search);
      var file = params.get("file");
      var rule = params.get("rule");
      var useRuleExemptions = params.get("exemptions") == 'true';

      tagList = new TagList(document.getElementById("tag_list"));

      await changePageState({fileID: file, ruleName: rule, useRuleExemptions: useRuleExemptions});
    })
  </script>
{% endblock %}

{% block content %}
  <div class="full_file_sidebar">
    <h2 id="file_title"></h2>
    <p>
      <a id="direct_download">Direct Download</a>
    </p>

    <!-- <h3>Tools</h3> <button onclick="addTag()">Quick Add Tag</button><br> <button onclick="removeTag()">Quick Remove Tag</button><br> -->

    <h3 id="actions_header">Actions</h3>
    <div id="actions_container"></div>

    <h3 id="tags_header">Display Tags ({{server.tag_service}})</h3>
    <div id="tags_container">
      <ul id="tag_list"></ul>
    </div>

    <h3>Metadata</h3>
    <div id="metadata_container">
      <p>Hash:
        <code id="hash_container"></code>
      </p>
    </div>

    <h3 id="rule_header" style="display: none;">Rule Info</h3>
    <div id="rule_container"></div>
  </div>

  <div id="embed_target" class="full_file_container"></div>

{% endblock %}
